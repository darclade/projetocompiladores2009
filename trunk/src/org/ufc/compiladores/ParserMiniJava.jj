/**
 *
 * Analisador Lexico e Sintatico para Linguagem MiniJava 
 *
 */
 PARSER_BEGIN(ParserMiniJava)
 	class ParserMiniJava 
 	{
 		public static void main(String args[]) throws Exception
 		{
 			// Iniciamos um novo parser para a nossa gramatica
			ParserMiniJava parserMiniJava = new ParserMiniJava(System.in);
			
			// Checar os dados enquanto passarmos dados validos ao parser
		    while (true)
		    {
		        parserMiniJava.Start();
		    }
 		}
 	}
 PARSER_END(ParserMiniJava)
 
 /* Tokens */
 TOKEN: {
	  
	 <#LETRA: ["_","a"-"z","A"-"Z"]>
	| <#DIGITO: ["0"-"9"]>

 	| <MAINCLASS: "MainClass"> 
 	| <CLASS: "class">
 	| <PUBLIC: "public">
 	| <STATIC: "static">
 	| <VOID: "void">
 	| <MAIN: "main">
 	| <EXTENDS: "extends">
	| <RETURN: "return">

	| <STRING: "String">
	| <INT: "int">
	| <INT_VETOR: <INT><LBRACKET><RBRACKET>>
	| <BOOLEAN: "boolean">

	| <IF: "if">
	| <ELSE: "else">
	| <WHILE: "while">
	| <PRINT_LINE: "System.out.println">
	| <LENGTH: "length">

	| <RECEBE: "=">
	| <MENOR: "<">
	| <MAIOR: ">">
	| <NEGADO: "!">
	| <IGUAL: "==">
	| <E: "&&">
	| <OU: "||">
	| <MAIS: "+">
	| <MENOS: "-">
	| <ESTRELA: "*">
	| <BARRA: "/">

	| <INTEGER_LITERAL: <DIGITO> (<DIGITO>)*>
	| <BOOLEAN_LITERAL: ("true"|"false")>

	| <NEW: "new">
	| <THIS: "this">
 	
	| <LPAREN: "(">
	| <RPAREN: ")">
	| <LBRACE: "{">
	| <RBRACE: "}">
	| <LBRACKET: "[">
	| <RBRACKET: "]">
	| <PONTOVIRGULA: ";">
	| <VIRGULA: ",">
	| <PONTO: ".">
	
	| <ID: <LETRA> (<LETRA>|<DIGITO>)*>
}

 SKIP: {
 	  <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
 	| " "
 	| "\n"
 	| "\t"
 	| "\r"
 }
 
 void Start() : {}
{
Program() <EOF>
}

void Program() : {}
{
MainClass()(LOOKAHEAD(ClassDecl())ClassDecl() | Class())*
}

void MainClass() : {}
{ <CLASS> <ID> <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN>
<LPAREN> <STRING> <LBRACKET> <RBRACKET> <ID> <RPAREN>
<LBRACE> Statement() <RBRACE> <RBRACE>
}

void Class() : {}
{
<CLASS> <ID> <LBRACE> (Body())* <RBRACE>
}

void ClassDecl() : {}
{
<CLASS> <ID> <EXTENDS> <ID> <LBRACE> (Body())* <RBRACE>
}

void Body() : {}
{
VarDecl()
| MethodDecl()
}

void VarDecl() : {}
{
Type() <ID> <PONTOVIRGULA>
}

void MethodDecl() : {}
{
<PUBLIC> Type() <ID> <LPAREN> FormalList() <RPAREN>
<LBRACE>
(MethodBody())* <RETURN> Exp()<PONTOVIRGULA>
<RBRACE>
}

void MethodBody() : {}
{
LOOKAHEAD(VarDecl()) VarDecl()
| Statement()
}

void FormalList() : {}
{
[ Parameter() ( <VIRGULA> Parameter() )* ]
}

void Parameter() : {}
{
Type() <ID>
}

void Type() : {}
{
<BOOLEAN>
| <ID>
| LOOKAHEAD(<INT_VETOR>) <INT_VETOR>
| <INT>
}

void Object() : {}
{
<THIS>
| <ID>
}

void Statement() : {}
{
If()
| While()
| Print()
| Assignment()
| <LBRACE> (Statement())* <RBRACE>
}

void Assignment() : {}
{
(LOOKAHEAD(ArrayAssignment())ArrayAssignment() |
UnaryAssignment()) <PONTOVIRGULA>
}

void UnaryAssignment() : {}
{
[ LOOKAHEAD(2) Object() <PONTO> ]
<ID> <RECEBE> Exp()
}

void ArrayAssignment() : {}
{
[ LOOKAHEAD(2) Object() <PONTO> ]
<ID> <LBRACKET> Exp() <RBRACKET>
<RECEBE> Exp()
}

void If() : {}
{
<IF> <LPAREN> Exp() <RPAREN> Statement() <ELSE> Statement()
}

void Print() : {}
{
<PRINT_LINE> <LPAREN> Exp() <RPAREN> <PONTOVIRGULA>
}

void While() : {}
{
<WHILE> <LPAREN> Exp() <RPAREN> Statement()
}

void Exp() : {}
{
OrExp()
| NewObject()
}

void OrExp() : {}
{
AndExp() ( <OU> AndExp() )*
}

void AndExp() : {}
{
NotExp() ( <E> NotExp())*
}

void NotExp() : {}
{
[ <NEGADO> ] LGEExp()
}

void LGEExp() : {}
{
AdditiveExpression() ( ( <MAIOR> | <MENOR> | <IGUAL> ) AdditiveExpression())*
}

void AdditiveExpression() : {}
{
MultiplicativeExpression() ( ( <MAIS> | <MENOS> )
MultiplicativeExpression() )*
}

void MultiplicativeExpression() : {}
{
UnaryExpression() ( ( <ESTRELA> | <BARRA> ) UnaryExpression() )*
}

void UnaryExpression() : {}
{
[ <MENOS> ] Element()
}

void Element() : {}
{
<INTEGER_LITERAL>
| <BOOLEAN_LITERAL>
| IdExp()
| <LPAREN> Exp() <RPAREN>
}

void IdExp() : {}
{
LOOKAHEAD( <ID> <PONTO><LENGTH> ) <ID> <PONTO> <LENGTH>
| [ LOOKAHEAD(Object() <PONTO>) Object() <PONTO> ] <ID> [ <LBRACKET>
Exp() <RBRACKET>
| <PONTO> <LENGTH>
| <LPAREN> ExpList() <RPAREN>  ]
}

void NewObject() : {}
{
<NEW> ( <INT> <LBRACKET> Exp() <RBRACKET> | <ID> <LPAREN>
<RPAREN> )
}

void ExpList() : {}
{
[ Exp() (<VIRGULA> Exp())* ]
}