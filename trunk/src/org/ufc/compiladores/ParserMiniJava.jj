/**
*
* Analisador Lexico e Sintatico para Linguagem MiniJava
*
*/

PARSER_BEGIN(ParserMiniJava)
import syntaxtree.*;
import visitor.*;
public class ParserMiniJava
{
public static void main(String args[])
{
try
{	
// Iniciamos um novo parser para a nossa gramatica
ParserMiniJava parserMiniJava = new ParserMiniJava(System.in);
parserMiniJava.Start();
parserMiniJava.accept(new PrettyPrintVisitor());  
}
catch (ParseException e) 
{      
 System.out.println(e.toString());
}
}
}
PARSER_END(ParserMiniJava)

/* Tokens */
TOKEN: {

 <#LETRA: ["_","a"-"z","A"-"Z"]>
	| <#DIGITO: ["0"-"9"]>

 	| <MAINCLASS: "MainClass"> 
 	| <CLASS: "class">
 	| <PUBLIC: "public">
 	| <STATIC: "static">
 	| <VOID: "void">
 	| <MAIN: "main">
 	| <EXTENDS: "extends">
	| <RETURN: "return">

	| <STRING: "String">
	| <INT: "int">
	| <INT_VETOR: <INT><LBRACKET><RBRACKET>>
	| <BOOLEAN: "boolean">

	| <IF: "if">
	| <ELSE: "else">
	| <WHILE: "while">
	| <PRINT_LINE: "System.out.println">
	| <LENGTH: "length">

	| <RECEBE: "=">
	| <MENOR: "<">
	| <MAIOR: ">">
	| <NEGADO: "!">
	| <IGUAL: "==">
	| <E: "&&">
	| <OU: "||">
	| <MAIS: "+">
	| <MENOS: "-">
	| <ESTRELA: "*">
	| <BARRA: "/">

	| <INTEGER_LITERAL: <DIGITO> (<DIGITO>)*>
	| <TRUE: "true">
    | <FALSE: "false">
    
	| <NEW: "new">
	| <THIS: "this">
 	
	| <LPAREN: "(">
	| <RPAREN: ")">
	| <LBRACE: "{">
	| <RBRACE: "}">
	| <LBRACKET: "[">
	| <RBRACKET: "]">
	| <PONTOVIRGULA: ";">
	| <VIRGULA: ",">
	| <PONTO: ".">
	
	| <ID: <LETRA> (<LETRA>|<DIGITO>)*>
}

SKIP: {
<"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| " "
| "\n"
| "\t"
| "\r"
}

Program Start() : 
{ Program e; }
{ e =Program() { return e; }  <EOF> }

Program Program() : 
{ MainClass m1; ClassDeclList c1; Program p1; }
{
m1 = MainClass()(LOOKAHEAD(2) c1 = ClassDecl() { p1 = new Program(m1,c1); }
| c1 = Class() { p1 = new Program(m1,c1); }
 )*
 { return p1; }
}

MainClass MainClass() : 
{ MainClass m1; Identifier i1,i2; Statement s1; }
{ <CLASS> i1 = Id() <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN>
<LPAREN> <STRING> <LBRACKET> <RBRACKET> i2 = Id() <RPAREN>
<LBRACE> s1 = Statement() <RBRACE> <RBRACE>
{m1 = new MainClass(i1,i2,s1); }
{ return m1; }
}

ClassDeclList Class() : {}
{
<CLASS> <ID> <LBRACE> ( VarDecl() | MethodDecl() )* <RBRACE>
}

ClassDeclList ClassDecl() : {}
{
<CLASS> <ID> <EXTENDS> <ID> <LBRACE> ( VarDecl() | MethodDecl() )* <RBRACE>
}

VarDecl VarDecl() : 
{ Type t1; Identifier i1; VarDecl v1; }
{
t1 = Type() i1 = Id() <PONTOVIRGULA>
{ v1 = new VarDecl(t1,i1); }
{return v1; }
}

Identifier Id() : {Token t;}
{ 
t = <ID> { return new Identifier(t.image); }
}

MethodDecl MethodDecl() : 
{ Type t1; Identifier i1; FormalList f1; VarDeclList v1[];
  StatementList s1[]; Exp e1; MethodDecl m1; }
{
<PUBLIC> t1 = Type() i1 = Id() <LPAREN> f1 = FormalList() <RPAREN>
<LBRACE> ( v1 = VarDecl() | s1 = Statement() )* 
<RETURN> e1 = Exp() <PONTOVIRGULA> <RBRACE>
{ m1 = new MethodDecl(t1,i1,f1,v1,s1,e1); }
{return m1; }
}

void MethodBody() : {}
{
LOOKAHEAD(2) VarDecl()
| Statement()
}

void FormalList() : {}
{
[ Type() <ID> ( <VIRGULA> Type() <ID> )* ]
}

Type Type() : 
{ Token t; }
{
<BOOLEAN>
| t = <ID> { return new IdentifierType(t.image); }
| LOOKAHEAD(2) <INT_VETOR>
| <INT> 
}

Exp Object() : 
{ Token t;}
{
<THIS> 
| t = <ID> {return new IdentifierExp(t.image); }
}

Statement Statement() : {}
{
If()
| While()
| Print()
| (LOOKAHEAD(ArrayAssignment())ArrayAssignment() | UnaryAssignment()) <PONTOVIRGULA>
| <LBRACE> (Statement())* <RBRACE>
}

Statement UnaryAssignment() : 
{ Identifier i1; Exp e1; Statement s1; }
{
[ LOOKAHEAD(2) Object() <PONTO> ] i1 = Id() <RECEBE> e1 = Exp()
{ s1 = new Assign(i1,e1); }
{return s1; }
}

Statement ArrayAssignment() : 
{ Exp e1,e2; Statement s1; Identifier i1; }
{
[ LOOKAHEAD(2) Object() <PONTO> ]
i1 = Id() <LBRACKET> e1 = Exp() <RBRACKET>
<RECEBE> e2 = Exp() { s1 = new ArrayAssign(i1,e1,e2); }
{ return s1; } 
}

Statement If() : 
{ Exp e1; Statement s1,s2,s3; }
{
<IF> <LPAREN> e1 = Exp() <RPAREN> s1 =  Statement() 
<ELSE> s2 = Statement() { s3 = new If(e1,s1,s2); }
{ return s3; } 
}

Statement Print() : 
{ Exp e1; Statement s1; }
{
<PRINT_LINE> <LPAREN> e1 = Exp() <RPAREN> <PONTOVIRGULA>
{ s1 = new Print(e1); }
{ return s1; }
}

Statement While() : 
{ Exp e1; Statement s1,s2; }
{
<WHILE> <LPAREN> e1 = Exp() <RPAREN> s1 = Statement()
{ s2 = new While(e1,s1); }
{ return s2; } 
}

Exp Exp() : {}
{
OrExp()
| NewObject()
}

Exp OrExp() : 
{ Exp e1,e2; }
{
e1 = AndExp() ( <OU> e2= AndExp() { e1 = new Or(e1,e2); } )*
{ return e1; }
}

Exp AndExp() : 
{ Exp e1,e2; }
{
e1 = NotExp() ( <E> e2 = NotExp() { e1 = new And(e1,e2); } )*
{ return e1; }
}

Exp NotExp() : 
{ Exp e1; }
{
[ <NEGADO> ] e1 = LGEExp() { e1 = new Not(e1); } 
{ return e1; }
}

Exp LGEExp() : 
{ Exp e1,e2; }
{
e1 = AdditiveExpression() 
  ( <MAIOR> e2 = AdditiveExpression() { e1 = new MoreThan(e1,e2); } 
  | <MENOR> e2 = AdditiveExpression() { e1 = new LessThan(e1,e2); }
  | <IGUAL> e2 = AdditiveExpression() { e1 = new Equal(e1,e2); } 
  )*
  { return e1; }
}

Exp AdditiveExpression() : 
{ Exp e1,e2; }
{
e1 = MultiplicativeExpression() 
  ( <MAIS> e2 = MultiplicativeExpression() { e1 = new Plus(e1,e2); }
  | <MENOS> e2 = MultiplicativeExpression()  { e1 = new Minus(e1,e2); }
  )*
  { return e1; } 
}

Exp MultiplicativeExpression() : 
{ Exp e1,e2; }
{
e1 = UnaryExpression() 
  (  <ESTRELA> e2 = UnaryExpression() { e1 = new Times(e1,e2); } )*
  { return e1; }
}

Exp UnaryExpression() : 
{ Exp e1,e2; }
{
[ <MENOS> ] e1 = Element() { e2 = new Not(e1); }
{return e2; } 
}

Exp Element() : {}
{
<INTEGER_LITERAL>
| <TRUE> 
| <FALSE> 
| IdExp()
| <LPAREN> Exp() <RPAREN>
}

Exp IdExp() : {}
{
LOOKAHEAD(2) <ID> <PONTO> <LENGTH>
| [ LOOKAHEAD(2) Object() <PONTO> ] <ID> [ <LBRACKET> Exp() <RBRACKET>
| <PONTO> <LENGTH>
| <LPAREN> ExpList() <RPAREN> ]
}

Exp NewObject() : 
{ Identifier i1; Exp e1;}
{
<NEW> i1 = Id() <LPAREN> <RPAREN> { e1 = new NewObject(i1); } 
{ return e1; }
}

ExpList ExpList() : {}
{
[ Exp() (<VIRGULA> Exp())* ]
}

