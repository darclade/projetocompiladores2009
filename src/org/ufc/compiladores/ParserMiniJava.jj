/**
*
* Analisador Lexico e Sintatico para Linguagem MiniJava
*
*/

PARSER_BEGIN(ParserMiniJava)
import syntaxtree.*;
import visitor.*;
public class ParserMiniJava
{
public static void main(String args[])
{
try
{	
// Iniciamos um novo parser para a nossa gramatica
ParserMiniJava parserMiniJava = new ParserMiniJava(System.in);
parserMiniJava.Start();
//parserMiniJava.accept(new PrettyPrintVisitor());  
}
catch (ParseException e) 
{      
 System.out.println(e.toString());
}
}
}
PARSER_END(ParserMiniJava)

/* Tokens */
TOKEN: {

 <#LETRA: ["_","a"-"z","A"-"Z"]>
	| <#DIGITO: ["0"-"9"]>

 	| <MAINCLASS: "MainClass"> 
 	| <CLASS: "class">
 	| <PUBLIC: "public">
 	| <STATIC: "static">
 	| <VOID: "void">
 	| <MAIN: "main">
 	| <EXTENDS: "extends">
	| <RETURN: "return">

	| <STRING: "String">
	| <INT: "int">
	| <INT_VETOR: <INT><LBRACKET><RBRACKET>>
	| <BOOLEAN: "boolean">

	| <IF: "if">
	| <ELSE: "else">
	| <WHILE: "while">
	| <PRINT_LINE: "System.out.println">
	| <LENGTH: "length">

	| <RECEBE: "=">
	| <MENOR: "<">
	| <MAIOR: ">">
	| <NEGADO: "!">
	| <IGUAL: "==">
	| <E: "&&">
	| <OU: "||">
	| <MAIS: "+">
	| <MENOS: "-">
	| <ESTRELA: "*">
	| <BARRA: "/">

	| <INTEGER_LITERAL: <DIGITO> (<DIGITO>)*>
	| <TRUE: "true">
    | <FALSE: "false">
    
	| <NEW: "new">
	| <THIS: "this">
 	
	| <LPAREN: "(">
	| <RPAREN: ")">
	| <LBRACE: "{">
	| <RBRACE: "}">
	| <LBRACKET: "[">
	| <RBRACKET: "]">
	| <PONTOVIRGULA: ";">
	| <VIRGULA: ",">
	| <PONTO: ".">
	
	| <ID: <LETRA> (<LETRA>|<DIGITO>)*>
}

SKIP: {
<"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| " "
| "\n"
| "\t"
| "\r"
}

void Start() :
 { MainClass m1; 
   ClassDeclList c1 = new ClassDeclList(); ClassDecl c;
 }
 {  m1 = MainClass() 
 	( LOOKAHEAD(2) c = ClassDecl() { c1.addElement(c); }
    | c = Class() { c1.addElement(c); }
 )*
 <EOF> { new Program(m1,c1); }
 }

MainClass MainClass() : 
{ Identifier i1,i2; Statement s1; }
{ <CLASS> i1 = Id() <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN>
<LPAREN> <STRING> <LBRACKET> <RBRACKET> i2 = Id() <RPAREN>
<LBRACE> s1 = Statement() <RBRACE> <RBRACE>
{ return new MainClass(i1,i2,s1); }
}

ClassDeclSimple Class() : 
{ Identifier i1; VarDeclList v1 = new VarDeclList(); 
  MethodDeclList m1 = new MethodDeclList();
  VarDecl v; MethodDecl m;
}
{
<CLASS> i1 = Id() <LBRACE> 
( v = VarDecl() { v1.addElement(v); } 
| m = MethodDecl() { m1.addElement(m); } )* <RBRACE>
{ return new ClassDeclSimple(i1,v1,m1); } 
}

ClassDecl ClassDecl() : 
{ Identifier i1,i2; VarDeclList v1 = new VarDeclList(); 
  MethodDeclList m1 = new MethodDeclList();
  VarDecl v; MethodDecl m;
}
{
<CLASS> i1 = Id() <EXTENDS> i2 = Id() <LBRACE> 
( v = VarDecl() { v1.addElement(v); } 
| m = MethodDecl() { m1.addElement(m); } )* <RBRACE>
{ return new ClassDeclExtends(i1,i2,v1,m1); } 
}

VarDecl VarDecl() : 
{ Type t1; Identifier i1; VarDecl v1; }
{
t1 = Type() i1 = Id() <PONTOVIRGULA>
{ v1 = new VarDecl(t1,i1); }
{return v1; }
}

Identifier Id() : {Token t;}
{ 
t = <ID> { return new Identifier(t.image); }
}

MethodDecl MethodDecl() : 
{ Type t1; Identifier i1; 
  FormalList f1 = new FormalList(); 
  VarDeclList v1 = new VarDeclList() ; VarDecl v;
  StatementList s1 = new StatementList(); Statement s;
  Exp e1; }
{
<PUBLIC> t1 = Type() i1 = Id() <LPAREN> f1 = FormalList() <RPAREN> <LBRACE> 
( LOOKAHEAD(2) v = VarDecl() { v1.addElement(v); } 
| s = Statement() { s1.addElement(s); } )* <RETURN>
 e1 = Exp() <PONTOVIRGULA> <RBRACE>
{ return new MethodDecl(t1,i1,f1,v1,s1,e1); }
}


FormalList FormalList() : 
{ FormalList f1 = new FormalList(); 
  Formal f2,f3; Identifier i1,i2; Type t1,t2; }
{
[ t1 = Type() i1 =  Id() 
  { f2 = new Formal(t1,i1); f1.addElement(f2); }  
  ( <VIRGULA> t2 =  Type() i2 = Id() 
  { f3 = new Formal(t2,i2); f1.addElement(f3); } )* ]
  {return f1; }
}

Type Type() : 
{ Token t; }
{
<BOOLEAN>
| t = <ID> { return new IdentifierType(t.image); }
| LOOKAHEAD(2) <INT_VETOR>
| <INT> 
}

Exp Object() : 
{ Token t;}
{
<THIS> 
| t = <ID> {return new IdentifierExp(t.image); }

}

Statement Statement() : 
{Statement s; StatementList s1 = new StatementList();}
{
s = If() {return s;}
| s = While() {return s;}
| s = Print() {return s;}
| (LOOKAHEAD(ArrayAssignment())s = ArrayAssignment() {return s;} 
             | s = UnaryAssignment() {return s;} ) <PONTOVIRGULA>
| <LBRACE> (s = Statement() { s1.addElement(s); })* 
  {return new Block(s1);} <RBRACE>
}

Statement UnaryAssignment() : 
{ Identifier i1; Exp e1; Statement s1; }
{
[ LOOKAHEAD(2) Object() <PONTO> ] i1 = Id() <RECEBE> e1 = Exp()
{ s1 = new Assign(i1,e1); }
{return s1; }
}

Statement ArrayAssignment() : 
{ Exp e1,e2; Statement s1; Identifier i1; }
{
[ LOOKAHEAD(2) Object() <PONTO> ]
i1 = Id() <LBRACKET> e1 = Exp() <RBRACKET>
<RECEBE> e2 = Exp() { s1 = new ArrayAssign(i1,e1,e2); }
{ return s1; } 
}

Statement If() : 
{ Exp e1; Statement s1,s2,s3; }
{
<IF> <LPAREN> e1 = Exp() <RPAREN> s1 =  Statement() 
<ELSE> s2 = Statement() { s3 = new If(e1,s1,s2); }
{ return s3; } 
}

Statement Print() : 
{ Exp e1; Statement s1; }
{
<PRINT_LINE> <LPAREN> e1 = Exp() <RPAREN> <PONTOVIRGULA>
{ s1 = new Print(e1); }
{ return s1; }
}

Statement While() : 
{ Exp e1; Statement s1,s2; }
{
<WHILE> <LPAREN> e1 = Exp() <RPAREN> s1 = Statement()
{ s2 = new While(e1,s1); }
{ return s2; } 
}

Exp Exp() : { Exp e; }
{
e = OrExp() {return e;} 
| e = NewObject() {return e;}
}

Exp OrExp() : 
{ Exp e1,e2; }
{
e1 = AndExp() ( <OU> e2= AndExp() { e1 = new Or(e1,e2); } )*
{ return e1; }
}

Exp AndExp() : 
{ Exp e1,e2; }
{
e1 = NotExp() ( <E> e2 = NotExp() { e1 = new And(e1,e2); } )*
{ return e1; }
}

Exp NotExp() : 
{ Exp e1; }
{
[ <NEGADO> ] e1 = LGEExp() { e1 = new Not(e1); } 
{ return e1; }
}

Exp LGEExp() : 
{ Exp e1,e2; }
{
e1 = AdditiveExpression() 
  ( <MAIOR> e2 = AdditiveExpression() { e1 = new MoreThan(e1,e2); } 
  | <MENOR> e2 = AdditiveExpression() { e1 = new LessThan(e1,e2); }
  | <IGUAL> e2 = AdditiveExpression() { e1 = new Equal(e1,e2); } 
  )*
  { return e1; }
}

Exp AdditiveExpression() : 
{ Exp e1,e2; }
{
e1 = MultiplicativeExpression() 
  ( <MAIS> e2 = MultiplicativeExpression() { e1 = new Plus(e1,e2); }
  | <MENOS> e2 = MultiplicativeExpression()  { e1 = new Minus(e1,e2); }
  )*
  { return e1; } 
}

Exp MultiplicativeExpression() : 
{ Exp e1,e2; }
{
e1 = UnaryExpression() 
  (  <ESTRELA> e2 = UnaryExpression() { e1 = new Times(e1,e2); } )*
  { return e1; }
}

Exp UnaryExpression() : 
{ Exp e1,e2; }
{
[ <MENOS> ] e1 = Element() { e2 = new Not(e1); }
{return e2; } 
}

Exp Element() : 
{Exp e;}
{
<INTEGER_LITERAL>
| <TRUE> 
| <FALSE> 
| e = IdExp() {return e;}
| <LPAREN> e = Exp() <RPAREN> {return e;}
}

Exp IdExp() : 
{ Exp o1=null,o2; Identifier i1; ExpList e2 = new ExpList(); Exp e3; }
{ 
  LOOKAHEAD(2) o1 = Object() <PONTO> <LENGTH> { return new ArrayLength(o1); }
  | [ LOOKAHEAD(2) o1 = Object() <PONTO> ]  i1 = Id() [ <LPAREN> e2 = ExpList() <RPAREN> { return new Call(o1,i1,e2); }  
  | o2 = Object() <LBRACKET> e3 = Exp() <RBRACKET> { return new ArrayLookup(o2,e3); } ]
}

Exp NewObject() : 
{ Identifier i1; Exp e1;}
{
<NEW> i1 = Id() { e1 = new NewObject(i1); }  <LPAREN> <RPAREN> 
{ return e1; }
}

ExpList ExpList() : 
{ExpList e1 = new ExpList(); Exp e2,e3;}
{
[ e2 = Exp() { e1.addElement(e2); } 
 (<VIRGULA> e3 = Exp() { e1.addElement(e3); } )* ]
 { return e1; }
}

